import { Hono } from "hono";
import db from "../db";
import { sendMessage } from "../services/telegram-bot";

const app = new Hono();

// ---------- POST /telegram/pair ----------
// User enters a bot-generated pairing code from the frontend
app.post("/pair", async (c) => {
  const body = await c.req.json();
  const { walletAddress, pairingCode } = body;

  if (!walletAddress || !pairingCode) {
    return c.json({ error: "walletAddress and pairingCode are required" }, 400);
  }

  const code = pairingCode.trim().toUpperCase();

  // Check if this wallet already has an active connection
  const existingWallet = db
    .query(
      "SELECT * FROM telegram_connections WHERE wallet_address = ? AND status = 'paired'"
    )
    .get(walletAddress) as Record<string, unknown> | null;

  if (existingWallet) {
    return c.json(
      { error: "This wallet already has an active Telegram connection. Disconnect first." },
      409
    );
  }

  // Find the pending code generated by the bot
  const pending = db
    .query(
      "SELECT * FROM telegram_connections WHERE pairing_code = ? AND status = 'pending'"
    )
    .get(code) as Record<string, unknown> | null;

  if (!pending) {
    return c.json(
      { error: "Invalid or expired pairing code. Send /pair in the Telegram bot to get a new one." },
      404
    );
  }

  // Check expiry
  const expiresAt = pending.expires_at as string | null;
  if (expiresAt && new Date(expiresAt) < new Date()) {
    // Clean up expired code
    db.query("DELETE FROM telegram_connections WHERE id = ?").run(pending.id);
    return c.json(
      { error: "This pairing code has expired. Send /pair in Telegram to get a new one." },
      410
    );
  }

  // Check if this Telegram chat is already paired to another wallet
  const existingChat = db
    .query(
      "SELECT * FROM telegram_connections WHERE telegram_chat_id = ? AND status = 'paired'"
    )
    .get(pending.telegram_chat_id) as Record<string, unknown> | null;

  if (existingChat) {
    return c.json(
      { error: "This Telegram account is already paired to another wallet. Use /unpair in Telegram first." },
      409
    );
  }

  // Link the wallet and mark as paired
  db.query(
    `UPDATE telegram_connections SET
      wallet_address = ?,
      status = 'paired',
      paired_at = datetime('now'),
      updated_at = datetime('now')
     WHERE id = ?`
  ).run(walletAddress, pending.id);

  // Notify the user on Telegram
  const chatId = pending.telegram_chat_id as string;
  const shortAddr = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;

  sendMessage(
    Number(chatId),
    `*Account linked!*\n\n` +
      `Wallet: \`${shortAddr}\`\n\n` +
      `You'll now receive trade alerts and strategy notifications here.`
  ).catch((err) => console.error("Failed to send confirmation to Telegram:", err));

  return c.json({
    success: true,
    status: "paired",
    telegramUsername: pending.telegram_username || null,
    message: "Telegram paired successfully! You'll receive notifications in Telegram.",
  });
});

// ---------- GET /telegram/status ----------
// Check the pairing status for a wallet
app.get("/status", (c) => {
  const walletAddress = c.req.query("walletAddress");

  if (!walletAddress) {
    return c.json({ error: "walletAddress query param is required" }, 400);
  }

  const connection = db
    .query(
      "SELECT * FROM telegram_connections WHERE wallet_address = ? AND status = 'paired' LIMIT 1"
    )
    .get(walletAddress) as Record<string, unknown> | null;

  if (!connection) {
    return c.json({ connected: false, status: null });
  }

  return c.json({
    connected: true,
    status: "paired",
    telegramUsername: connection.telegram_username || null,
    pairedAt: connection.paired_at,
  });
});

// ---------- DELETE /telegram/disconnect ----------
// Disconnect the Telegram bot from a wallet
app.delete("/disconnect", async (c) => {
  const body = await c.req.json();
  const { walletAddress } = body;

  if (!walletAddress) {
    return c.json({ error: "walletAddress is required" }, 400);
  }

  // Find the connection to notify Telegram
  const connection = db
    .query(
      "SELECT * FROM telegram_connections WHERE wallet_address = ? AND status = 'paired'"
    )
    .get(walletAddress) as Record<string, unknown> | null;

  // Remove all records for this wallet
  db.query("DELETE FROM telegram_connections WHERE wallet_address = ?").run(
    walletAddress
  );

  // Notify user on Telegram if we had a connection
  if (connection?.telegram_chat_id) {
    sendMessage(
      Number(connection.telegram_chat_id),
      `Your wallet has been unlinked from the Bullseye app.\n\nUse /pair to reconnect anytime.`
    ).catch(() => {});
  }

  return c.json({ success: true, message: "Telegram disconnected" });
});

// ---------- GET /telegram/actions ----------
// Poll for pending actions queued by the Telegram bot
app.get("/actions", (c) => {
  const walletAddress = c.req.query("walletAddress");

  if (!walletAddress) {
    return c.json({ error: "walletAddress query param is required" }, 400);
  }

  const actions = db
    .query(
      "SELECT * FROM telegram_actions WHERE wallet_address = ? AND status = 'pending' ORDER BY created_at ASC LIMIT 10"
    )
    .all(walletAddress) as Array<Record<string, unknown>>;

  return c.json({
    actions: actions.map((a) => ({
      id: a.id,
      type: a.type,
      payload: JSON.parse(a.payload as string),
      createdAt: a.created_at,
    })),
  });
});

// ---------- POST /telegram/actions/:id/ack ----------
// Acknowledge (consume) an action so it won't be returned again
app.post("/actions/:id/ack", (c) => {
  const id = c.req.param("id");

  db.query(
    "UPDATE telegram_actions SET status = 'consumed' WHERE id = ?"
  ).run(id);

  // Clean up old consumed actions (> 1 hour)
  db.query(
    "DELETE FROM telegram_actions WHERE status = 'consumed' AND created_at < datetime('now', '-1 hour')"
  ).run();

  return c.json({ success: true });
});

export default app;
